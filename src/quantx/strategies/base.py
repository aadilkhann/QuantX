"""
Base Strategy Classes for QuantX

Provides abstract base classes for all trading strategies.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Any, Dict, Optional

import pandas as pd
from loguru import logger

from quantx.core.events import Event, EventBus, EventType


class Action(Enum):
    """Trading actions"""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class Signal:
    """Trading signal generated by strategy"""

    symbol: str
    action: Action
    quantity: int
    price: Optional[float] = None
    timestamp: Optional[datetime] = None
    strategy: Optional[str] = None
    metadata: Dict[str, Any] = None

    def __post_init__(self) -> None:
        """Set defaults after initialization"""
        if self.timestamp is None:
            self.timestamp = datetime.now()
        if self.metadata is None:
            self.metadata = {}

    def to_event(self) -> Event:
        """Convert signal to event"""
        return Event(
            priority=1,
            event_type=EventType.SIGNAL,
            timestamp=self.timestamp,
            data=self.__dict__,
            source=self.strategy or "unknown",
        )


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies

    All strategies must inherit from this class and implement the required methods.
    """

    def __init__(self, name: str, config: Dict[str, Any]) -> None:
        """
        Initialize strategy

        Args:
            name: Strategy name
            config: Strategy configuration
        """
        self.name = name
        self.config = config
        self.event_bus: Optional[EventBus] = None
        self.portfolio: Optional[Any] = None
        self._positions: Dict[str, int] = {}
        self._is_initialized = False

        logger.info("Strategy '{}' initialized with config: {}", name, config)

    def set_event_bus(self, event_bus: EventBus) -> None:
        """
        Set event bus for publishing signals

        Args:
            event_bus: EventBus instance
        """
        self.event_bus = event_bus
        logger.debug("Event bus set for strategy '{}'", self.name)

    def set_portfolio(self, portfolio: Any) -> None:
        """
        Set portfolio reference

        Args:
            portfolio: Portfolio instance
        """
        self.portfolio = portfolio
        logger.debug("Portfolio set for strategy '{}'", self.name)

    @abstractmethod
    def on_data(self, event: Event) -> None:
        """
        Called when new market data arrives

        Args:
            event: Market data event
        """
        pass

    @abstractmethod
    def on_fill(self, event: Event) -> None:
        """
        Called when an order is filled

        Args:
            event: Fill event
        """
        pass

    def on_start(self) -> None:
        """Called when strategy starts (optional override)"""
        logger.info("Strategy '{}' started", self.name)
        self._is_initialized = True

    def on_stop(self) -> None:
        """Called when strategy stops (optional override)"""
        logger.info("Strategy '{}' stopped", self.name)

    def buy(
        self, symbol: str, quantity: int, price: Optional[float] = None, **kwargs
    ) -> None:
        """
        Generate buy signal

        Args:
            symbol: Symbol to buy
            quantity: Quantity to buy
            price: Limit price (None for market order)
            **kwargs: Additional metadata
        """
        signal = Signal(
            symbol=symbol,
            action=Action.BUY,
            quantity=quantity,
            price=price,
            strategy=self.name,
            metadata=kwargs,
        )

        if self.event_bus:
            self.event_bus.publish(signal.to_event())
            logger.info("BUY signal: {} x{} @ {}", symbol, quantity, price or "market")
        else:
            logger.warning("Event bus not set, signal not published")

    def sell(
        self, symbol: str, quantity: int, price: Optional[float] = None, **kwargs
    ) -> None:
        """
        Generate sell signal

        Args:
            symbol: Symbol to sell
            quantity: Quantity to sell
            price: Limit price (None for market order)
            **kwargs: Additional metadata
        """
        signal = Signal(
            symbol=symbol,
            action=Action.SELL,
            quantity=quantity,
            price=price,
            strategy=self.name,
            metadata=kwargs,
        )

        if self.event_bus:
            self.event_bus.publish(signal.to_event())
            logger.info("SELL signal: {} x{} @ {}", symbol, quantity, price or "market")
        else:
            logger.warning("Event bus not set, signal not published")

    def has_position(self, symbol: str) -> bool:
        """
        Check if strategy has position in symbol

        Args:
            symbol: Symbol to check

        Returns:
            True if has position
        """
        return symbol in self._positions and self._positions[symbol] != 0

    def get_position(self, symbol: str) -> int:
        """
        Get current position quantity

        Args:
            symbol: Symbol to check

        Returns:
            Position quantity (positive for long, negative for short)
        """
        return self._positions.get(symbol, 0)

    def update_position(self, symbol: str, quantity: int) -> None:
        """
        Update position after fill

        Args:
            symbol: Symbol
            quantity: Quantity change (positive for buy, negative for sell)
        """
        current = self._positions.get(symbol, 0)
        self._positions[symbol] = current + quantity
        logger.debug("Position updated: {} = {}", symbol, self._positions[symbol])


class RuleBasedStrategy(BaseStrategy):
    """
    Base class for rule-based strategies

    Rule-based strategies use technical indicators and predefined rules
    to generate trading signals.
    """

    def __init__(self, name: str, config: Dict[str, Any]) -> None:
        """
        Initialize rule-based strategy

        Args:
            name: Strategy name
            config: Strategy configuration
        """
        super().__init__(name, config)
        logger.debug("RuleBasedStrategy '{}' initialized", name)


class AIPoweredStrategy(BaseStrategy):
    """
    Base class for AI-powered strategies

    AI-powered strategies use machine learning models to generate
    trading signals based on predictions.
    """

    def __init__(self, name: str, config: Dict[str, Any], model: Optional[Any] = None) -> None:
        """
        Initialize AI-powered strategy

        Args:
            name: Strategy name
            config: Strategy configuration
            model: ML model instance
        """
        super().__init__(name, config)
        self.model = model
        logger.debug("AIPoweredStrategy '{}' initialized", name)

    def set_model(self, model: Any) -> None:
        """
        Set ML model

        Args:
            model: Model instance
        """
        self.model = model
        logger.info("Model set for strategy '{}'", self.name)

    @abstractmethod
    def prepare_features(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Prepare features for model prediction

        Args:
            data: Market data

        Returns:
            Feature DataFrame
        """
        pass


class HybridStrategy(BaseStrategy):
    """
    Base class for hybrid strategies

    Hybrid strategies combine AI predictions with rule-based filters
    to generate trading signals.
    """

    def __init__(
        self,
        name: str,
        config: Dict[str, Any],
        ai_strategy: Optional[AIPoweredStrategy] = None,
        rule_strategy: Optional[RuleBasedStrategy] = None,
    ) -> None:
        """
        Initialize hybrid strategy

        Args:
            name: Strategy name
            config: Strategy configuration
            ai_strategy: AI-powered strategy component
            rule_strategy: Rule-based strategy component
        """
        super().__init__(name, config)
        self.ai_strategy = ai_strategy
        self.rule_strategy = rule_strategy
        logger.debug("HybridStrategy '{}' initialized", name)

    def set_ai_strategy(self, strategy: AIPoweredStrategy) -> None:
        """Set AI strategy component"""
        self.ai_strategy = strategy

    def set_rule_strategy(self, strategy: RuleBasedStrategy) -> None:
        """Set rule-based strategy component"""
        self.rule_strategy = strategy
